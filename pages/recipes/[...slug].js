import { NextSeo } from "next-seo";
import { IMAGE_URL } from "../../lib/constants.js";
import { isMultiLanguage } from "../../lib/isMultiLanguage";
import { getPreview } from "../../lib/getPreview";
import { getPaths } from "../../lib/getPaths";
import {
  getCurrentLocaleStore,
  globalDrupalStateAuthStores,
  globalDrupalStateStores,
} from "../../lib/drupalStateContext.js";
import Link from "next/link";
import Image from "next/image";
import Layout from "../../components/layout";

// This file can safely be removed if the Drupal
// instance is not sourcing Umami data
export default function RecipeTemplate({ recipe, footerMenu, hrefLang }) {
  const imgSrc = recipe?.field_media_image?.field_media_image?.uri?.url;

  return (
    <Layout footerMenu={footerMenu}>
      <NextSeo
        title="Decoupled Next Drupal Demo"
        description="Generated by create next app."
        languageAlternates={hrefLang || false}
      />
      <article className="prose lg:prose-xl mt-10 mx-auto h-fit p-4 sm:p-0">
        <header>
          <h1>{recipe.title}</h1>
          <div className="flex flex-row justify-between">
            <Link passHref href="/recipes">
              <a className="font-normal">Recipes &rarr;</a>
            </Link>
            <span className="text pb-2 pr-3 text-sm text-slate-400">
              {recipe.field_recipe_category[0].name}
            </span>
          </div>
        </header>
        {imgSrc ? (
          <div className="relative max-w-lg mx-auto min-w-full h-[50vh] rounded-lg shadow-lg overflow-hidden mt-12 mb-10">
            <Image
              src={IMAGE_URL + imgSrc}
              layout="fill"
              objectFit="cover"
              alt={recipe.title}
            />
          </div>
        ) : null}

        <div className="flex flex-col sm:flex-row">
          <section className="flex flex-col min-w-fit sm:border-r-2 pr-4">
            <h2>Ingredients</h2>
            <ul>
              {recipe.field_ingredients?.map((ingredient, i) => {
                if (ingredient.startsWith("For")) {
                  return (
                    <li className="list-none" key={i}>
                      <strong>{ingredient}</strong>
                    </li>
                  );
                } else {
                  return <li key={i}>{ingredient}</li>;
                }
              })}
            </ul>
          </section>
          <section className="flex flex-col pl-4">
            <h2 className="ml-4">Directions</h2>
            <div
              dangerouslySetInnerHTML={{
                __html: recipe.field_recipe_instruction.value,
              }}
            />
          </section>
        </div>
      </article>
    </Layout>
  );
}

export async function getStaticPaths(context) {
  try {
    const paths = await getPaths(
      context,
      globalDrupalStateStores,
      "node--recipe",
      "slug",
      "recipes",
      true // failGracefully
    );

    return {
      paths,
      fallback: false,
    };
  } catch (error) {
    console.error("Failed to fetch paths for recipes:", error);
  }
}

export async function getStaticProps(context) {
  const { locales, locale } = context;
  const multiLanguage = isMultiLanguage(locales);
  const lang = context.preview ? context.previewData.previewLang : locale;
  const store = getCurrentLocaleStore(
    lang,
    context.preview ? globalDrupalStateAuthStores : globalDrupalStateStores
  );

  // handle nested slugs like /recipes/featured
  const slug = `/recipes${context.params.slug
    .map((segment) => `/${segment}`)
    .join("")}`;

  const params =
    "include=field_media_image.field_media_image,field_recipe_category";
  const previewParams =
    context.preview && (await getPreview(context, "node--recipe", params));

  try {
    const recipe = await store.getObjectByPath({
      objectName: "node--recipe",
      path: `${multiLanguage ? lang : ""}${slug}`,
      query: `{
        id
        title
        field_ingredients
        field_recipe_instruction
        field_summary
        field_media_image
        field_recipe_category {
          name
        }
        path {
          alias
          langcode
        }
      }`,
      // if preview is true, force a fetch to Drupal
      refresh: context.preview,
      params: context.preview ? previewParams : params,
    });

    const footerMenu = await store.getObject({
      objectName: "menu_items--main",
    });

    if (!recipe) {
      return { props: { footerMenu }, revalidate: 5 };
    }

    const origin = process.env.NEXT_PUBLIC_FRONTEND_URL;
    // Load all the paths for the current recipe.
    const paths = locales.map(async (locale) => {
      const storeByLocales = getCurrentLocaleStore(
        locale,
        context.preview ? globalDrupalStateAuthStores : globalDrupalStateStores
      );
      const { path } = await storeByLocales.getObject({
        objectName: "node--recipe",
        id: recipe.id,
        params: context.preview ? previewParams : params,
      });
      return path;
    });

    // Resolve all promises returned as part of paths
    // and prepare hrefLang.
    const hrefLang = await Promise.all(paths).then((values) => {
      return values.map((value) => {
        return {
          hrefLang: value.langcode,
          href: origin + "/" + value.langcode + value.alias,
        };
      });
    });

    return {
      props: {
        recipe,
        footerMenu,
        hrefLang,
      },
      revalidate: 60,
    };
  } catch (error) {
    console.error("Unable to fetch data for recipe: ", error);
    return {
      notFound: true,
      revalidate: 5,
    };
  }
}
